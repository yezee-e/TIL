>* **알고리즘-** 여러개의 지시사항, 어떠한 액션을 수행하기 위해 컴퓨터가 수행해야하는 것들
>* **데이터구조-** 데이터구조는 결국 이 데이터를 정리하는 것,
   각각의 데이터 구조에 대한 이해도가 필요(4가지 오퍼레이션 상황에 맞춰서)1.검색 2.읽기 3.삽입 4.삭제

<br/>
<br/>

## arry배열
***
* **시간복잡도**   
  데이터 구조의 오포페이션 혹은 알고리즘이 얼마나 빠르고 느린지 측정하는 방법   
  시간으로 측정하는 것이 아닌 얼마나 많은 단계(step)가 있는가로 측정
  <br/>  
 //메모리의 두가지 구조-> volatile(휘발성)메모리 VS non-volatile(비휘발성)메모리   
  휘발성메모리의 예시는 RAM 비휘발성메모리의 예시는 하드웨어   
배열의   
>**1)읽기.**  시간복잡도 기준에서 arry는 짱임(왜냐하면 모두 random access덕분)   
**2)검색.**  검색은 읽기와 달리 시간이 더 걸림 (선형검색:순서대로 0부터 끝까지 차근차근 찾는 것)   
**3)삽입.**  "어디에"추가할 것인가가 중요한 부분->가장 시간복잡도 순으로 좋은 것은 맨뒤추가(GOOD)<가운대추가<맨앞추가(BAD)<공간이상의 배열추가   
**4)삭제.**   삽입과 비슷

<br/>
<br/>

## 검색 알고리즘
***
* **binary search(이진검색 알고리즘)**  
모든 배열에 쓸수는 없음.    
sorted arry(정렬된 배열에서만 사용가능)   
sorted arry는 자료를 정리하여 배열들이 순서대로 정렬된 경우를 뜻함(정렬이 안된 배열보다 시간이 더 걸림, 왜냐? 규칙에 맞춰야하기 때문에)    
이진은 하나를 두개로 쪼개는 것을 뜻함(이진검색은 매 스탭마다  절반의 아이템을 없앰)   
따라서 이진 검색은 거대한 배열을 다룰때 효율적임 단, 이진검색을 하고 싶다면 배열을 정렬해야함
<br/>

* **linear search(선형검색 알고리즘)**    
어느배열에서도 사용가능.   
처음부터 끝까지 찾는 것을 확인 즉, 자료가 많고 찾는 것이 뒤에 있을 수록 시간이 길어짐 이것이 =선형 시간복잡도   
인풋사이즈가 n이라면 선형검색알고리즘은 n스탭이 요구됨 (선형검색의 시간 복잡도 =0(n))   

<br/>
<br/>

## Big O
***
알고리즘의 스피드를 표현하는 방식   
Big O를 사용하면 시간복잡도를 빠르게 설명가능 /  함수의 디테일에는 관심이 없음. 인풋 사이즈에 따라 함수가 어떻게 작동하는지에만 관심


>* ** 상수시간 복잡도 0(1)**  -> 는 상수(constant)에 신경을 쓰지 않음---인풋이 늘어나도 변하지 않음, 즉 가장 빠르고 선호됨
  <br/>
  
>* ** 로그시간 복잡도0(logn** )   -> 는 이진 알고리즘을 설명할때 
  <br/>
  
>* ** 선형검색의 시간 복잡도0(n)**  -> 인풋사이즈가 n이라면 선형검색알고리즘은 n스탭이 요구됨
  <br/>
  
>* ** 2차시간 복잡도0(n²)** ->지수시간 복잡도라고도 한다. 중첩반복이 있을때 발생---가장 복잡하고 느림
                               

로그(logarithm)<->지수(exponent)   
예를 들어))32를 2로 몇번 나눠야 1이 나올까 <->2를 몇번 곱해야 32가 나올까

<br/>
<br/>

## sorting 알고리즘
***
뭔가를 정리하는 것 ex)A-Z까지 기준으로 정렬

>* **Bubble sort(버블정렬):느림->**  배열의 2가지 아이템을 비교해서 계속해서 비교정렬 ---0(n²)

>* **Selction sort(선택정렬):중간->** 정렬되지 않은 배열에서 가장 작은 숫자를 찾고 정렬된 배열을 제외하고 계속 서치 -----0(n²)

>* **Insertion sort(삽입정렬):빠름->** 필요한 아이템만 스캔 ------0(n²)

==하지만 Big O기준으로는 다 0(n²)으로 분류   
==삽입, 선택 정렬은 작은 DB기준으로는 훌륭한 알고리즘

<br/>
<br/>

## Hash Table(해시 테이블)------0(1)
***
key value system을 이용하여 자료를 정리   
constant time(상수시간)   
해쉬충돌이 있을경우에는 선행검색을 함

<br/>
<br/>

## Queue&stack
***
추상적 자료구조(ADT)라고 불림-> 자료구조의 방법이 코드로 정의된 것이 아니라 그 구조의 행동양식만 정의된 것   

 * **'stack'**   배열이 수직으로 쌓여있는것 ex)팬케이크   
      이 배열에서 요소를 추가하거나 삭제할때 맨위에서 부터 차례로 제거   
      이런 방식을 LiFo라고함(last in, first out)   
* **'queue'**   배열이 가로로 쌓여있는것 ex)버스기다리는줄   
    가장 먼저 '큐'에 입장한 요소가 가장 먼저 '큐'에서 나가는 요소가됨   
    이런 방식을 FiFo라고함(first in, first out)
